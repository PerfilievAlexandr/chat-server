// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/PerfilievAlexandr/chat-server/internal/repository.MessageRepository -o message_repository_minimock.go -n MessageRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/PerfilievAlexandr/chat-server/internal/api/grpc/chat/dto"
	"github.com/PerfilievAlexandr/chat-server/internal/domain"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"google.golang.org/protobuf/types/known/emptypb"
)

// MessageRepositoryMock implements repository.MessageRepository
type MessageRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDelete          func(ctx context.Context, messageId int64) (e1 emptypb.Empty, err error)
	inspectFuncDelete   func(ctx context.Context, messageId int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mMessageRepositoryMockDelete

	funcGetMessagesByChatId          func(ctx context.Context, chatId uuid.UUID) (ma1 []domain.Message, err error)
	inspectFuncGetMessagesByChatId   func(ctx context.Context, chatId uuid.UUID)
	afterGetMessagesByChatIdCounter  uint64
	beforeGetMessagesByChatIdCounter uint64
	GetMessagesByChatIdMock          mMessageRepositoryMockGetMessagesByChatId

	funcSaveMessage          func(ctx context.Context, req dto.SendMessageRequest) (m1 domain.Message, err error)
	inspectFuncSaveMessage   func(ctx context.Context, req dto.SendMessageRequest)
	afterSaveMessageCounter  uint64
	beforeSaveMessageCounter uint64
	SaveMessageMock          mMessageRepositoryMockSaveMessage
}

// NewMessageRepositoryMock returns a mock for repository.MessageRepository
func NewMessageRepositoryMock(t minimock.Tester) *MessageRepositoryMock {
	m := &MessageRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mMessageRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*MessageRepositoryMockDeleteParams{}

	m.GetMessagesByChatIdMock = mMessageRepositoryMockGetMessagesByChatId{mock: m}
	m.GetMessagesByChatIdMock.callArgs = []*MessageRepositoryMockGetMessagesByChatIdParams{}

	m.SaveMessageMock = mMessageRepositoryMockSaveMessage{mock: m}
	m.SaveMessageMock.callArgs = []*MessageRepositoryMockSaveMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMessageRepositoryMockDelete struct {
	mock               *MessageRepositoryMock
	defaultExpectation *MessageRepositoryMockDeleteExpectation
	expectations       []*MessageRepositoryMockDeleteExpectation

	callArgs []*MessageRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// MessageRepositoryMockDeleteExpectation specifies expectation struct of the MessageRepository.Delete
type MessageRepositoryMockDeleteExpectation struct {
	mock    *MessageRepositoryMock
	params  *MessageRepositoryMockDeleteParams
	results *MessageRepositoryMockDeleteResults
	Counter uint64
}

// MessageRepositoryMockDeleteParams contains parameters of the MessageRepository.Delete
type MessageRepositoryMockDeleteParams struct {
	ctx       context.Context
	messageId int64
}

// MessageRepositoryMockDeleteResults contains results of the MessageRepository.Delete
type MessageRepositoryMockDeleteResults struct {
	e1  emptypb.Empty
	err error
}

// Expect sets up expected params for MessageRepository.Delete
func (mmDelete *mMessageRepositoryMockDelete) Expect(ctx context.Context, messageId int64) *mMessageRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessageRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &MessageRepositoryMockDeleteParams{ctx, messageId}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the MessageRepository.Delete
func (mmDelete *mMessageRepositoryMockDelete) Inspect(f func(ctx context.Context, messageId int64)) *mMessageRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for MessageRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by MessageRepository.Delete
func (mmDelete *mMessageRepositoryMockDelete) Return(e1 emptypb.Empty, err error) *MessageRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessageRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &MessageRepositoryMockDeleteResults{e1, err}
	return mmDelete.mock
}

// Set uses given function f to mock the MessageRepository.Delete method
func (mmDelete *mMessageRepositoryMockDelete) Set(f func(ctx context.Context, messageId int64) (e1 emptypb.Empty, err error)) *MessageRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the MessageRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the MessageRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the MessageRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mMessageRepositoryMockDelete) When(ctx context.Context, messageId int64) *MessageRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &MessageRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &MessageRepositoryMockDeleteParams{ctx, messageId},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up MessageRepository.Delete return parameters for the expectation previously defined by the When method
func (e *MessageRepositoryMockDeleteExpectation) Then(e1 emptypb.Empty, err error) *MessageRepositoryMock {
	e.results = &MessageRepositoryMockDeleteResults{e1, err}
	return e.mock
}

// Delete implements repository.MessageRepository
func (mmDelete *MessageRepositoryMock) Delete(ctx context.Context, messageId int64) (e1 emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, messageId)
	}

	mm_params := MessageRepositoryMockDeleteParams{ctx, messageId}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.e1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := MessageRepositoryMockDeleteParams{ctx, messageId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("MessageRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the MessageRepositoryMock.Delete")
		}
		return (*mm_results).e1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, messageId)
	}
	mmDelete.t.Fatalf("Unexpected call to MessageRepositoryMock.Delete. %v %v", ctx, messageId)
	return
}

// DeleteAfterCounter returns a count of finished MessageRepositoryMock.Delete invocations
func (mmDelete *MessageRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of MessageRepositoryMock.Delete invocations
func (mmDelete *MessageRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to MessageRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mMessageRepositoryMockDelete) Calls() []*MessageRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*MessageRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *MessageRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *MessageRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to MessageRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to MessageRepositoryMock.Delete")
	}
}

type mMessageRepositoryMockGetMessagesByChatId struct {
	mock               *MessageRepositoryMock
	defaultExpectation *MessageRepositoryMockGetMessagesByChatIdExpectation
	expectations       []*MessageRepositoryMockGetMessagesByChatIdExpectation

	callArgs []*MessageRepositoryMockGetMessagesByChatIdParams
	mutex    sync.RWMutex
}

// MessageRepositoryMockGetMessagesByChatIdExpectation specifies expectation struct of the MessageRepository.GetMessagesByChatId
type MessageRepositoryMockGetMessagesByChatIdExpectation struct {
	mock    *MessageRepositoryMock
	params  *MessageRepositoryMockGetMessagesByChatIdParams
	results *MessageRepositoryMockGetMessagesByChatIdResults
	Counter uint64
}

// MessageRepositoryMockGetMessagesByChatIdParams contains parameters of the MessageRepository.GetMessagesByChatId
type MessageRepositoryMockGetMessagesByChatIdParams struct {
	ctx    context.Context
	chatId uuid.UUID
}

// MessageRepositoryMockGetMessagesByChatIdResults contains results of the MessageRepository.GetMessagesByChatId
type MessageRepositoryMockGetMessagesByChatIdResults struct {
	ma1 []domain.Message
	err error
}

// Expect sets up expected params for MessageRepository.GetMessagesByChatId
func (mmGetMessagesByChatId *mMessageRepositoryMockGetMessagesByChatId) Expect(ctx context.Context, chatId uuid.UUID) *mMessageRepositoryMockGetMessagesByChatId {
	if mmGetMessagesByChatId.mock.funcGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("MessageRepositoryMock.GetMessagesByChatId mock is already set by Set")
	}

	if mmGetMessagesByChatId.defaultExpectation == nil {
		mmGetMessagesByChatId.defaultExpectation = &MessageRepositoryMockGetMessagesByChatIdExpectation{}
	}

	mmGetMessagesByChatId.defaultExpectation.params = &MessageRepositoryMockGetMessagesByChatIdParams{ctx, chatId}
	for _, e := range mmGetMessagesByChatId.expectations {
		if minimock.Equal(e.params, mmGetMessagesByChatId.defaultExpectation.params) {
			mmGetMessagesByChatId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMessagesByChatId.defaultExpectation.params)
		}
	}

	return mmGetMessagesByChatId
}

// Inspect accepts an inspector function that has same arguments as the MessageRepository.GetMessagesByChatId
func (mmGetMessagesByChatId *mMessageRepositoryMockGetMessagesByChatId) Inspect(f func(ctx context.Context, chatId uuid.UUID)) *mMessageRepositoryMockGetMessagesByChatId {
	if mmGetMessagesByChatId.mock.inspectFuncGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("Inspect function is already set for MessageRepositoryMock.GetMessagesByChatId")
	}

	mmGetMessagesByChatId.mock.inspectFuncGetMessagesByChatId = f

	return mmGetMessagesByChatId
}

// Return sets up results that will be returned by MessageRepository.GetMessagesByChatId
func (mmGetMessagesByChatId *mMessageRepositoryMockGetMessagesByChatId) Return(ma1 []domain.Message, err error) *MessageRepositoryMock {
	if mmGetMessagesByChatId.mock.funcGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("MessageRepositoryMock.GetMessagesByChatId mock is already set by Set")
	}

	if mmGetMessagesByChatId.defaultExpectation == nil {
		mmGetMessagesByChatId.defaultExpectation = &MessageRepositoryMockGetMessagesByChatIdExpectation{mock: mmGetMessagesByChatId.mock}
	}
	mmGetMessagesByChatId.defaultExpectation.results = &MessageRepositoryMockGetMessagesByChatIdResults{ma1, err}
	return mmGetMessagesByChatId.mock
}

// Set uses given function f to mock the MessageRepository.GetMessagesByChatId method
func (mmGetMessagesByChatId *mMessageRepositoryMockGetMessagesByChatId) Set(f func(ctx context.Context, chatId uuid.UUID) (ma1 []domain.Message, err error)) *MessageRepositoryMock {
	if mmGetMessagesByChatId.defaultExpectation != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("Default expectation is already set for the MessageRepository.GetMessagesByChatId method")
	}

	if len(mmGetMessagesByChatId.expectations) > 0 {
		mmGetMessagesByChatId.mock.t.Fatalf("Some expectations are already set for the MessageRepository.GetMessagesByChatId method")
	}

	mmGetMessagesByChatId.mock.funcGetMessagesByChatId = f
	return mmGetMessagesByChatId.mock
}

// When sets expectation for the MessageRepository.GetMessagesByChatId which will trigger the result defined by the following
// Then helper
func (mmGetMessagesByChatId *mMessageRepositoryMockGetMessagesByChatId) When(ctx context.Context, chatId uuid.UUID) *MessageRepositoryMockGetMessagesByChatIdExpectation {
	if mmGetMessagesByChatId.mock.funcGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("MessageRepositoryMock.GetMessagesByChatId mock is already set by Set")
	}

	expectation := &MessageRepositoryMockGetMessagesByChatIdExpectation{
		mock:   mmGetMessagesByChatId.mock,
		params: &MessageRepositoryMockGetMessagesByChatIdParams{ctx, chatId},
	}
	mmGetMessagesByChatId.expectations = append(mmGetMessagesByChatId.expectations, expectation)
	return expectation
}

// Then sets up MessageRepository.GetMessagesByChatId return parameters for the expectation previously defined by the When method
func (e *MessageRepositoryMockGetMessagesByChatIdExpectation) Then(ma1 []domain.Message, err error) *MessageRepositoryMock {
	e.results = &MessageRepositoryMockGetMessagesByChatIdResults{ma1, err}
	return e.mock
}

// GetMessagesByChatId implements repository.MessageRepository
func (mmGetMessagesByChatId *MessageRepositoryMock) GetMessagesByChatId(ctx context.Context, chatId uuid.UUID) (ma1 []domain.Message, err error) {
	mm_atomic.AddUint64(&mmGetMessagesByChatId.beforeGetMessagesByChatIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMessagesByChatId.afterGetMessagesByChatIdCounter, 1)

	if mmGetMessagesByChatId.inspectFuncGetMessagesByChatId != nil {
		mmGetMessagesByChatId.inspectFuncGetMessagesByChatId(ctx, chatId)
	}

	mm_params := MessageRepositoryMockGetMessagesByChatIdParams{ctx, chatId}

	// Record call args
	mmGetMessagesByChatId.GetMessagesByChatIdMock.mutex.Lock()
	mmGetMessagesByChatId.GetMessagesByChatIdMock.callArgs = append(mmGetMessagesByChatId.GetMessagesByChatIdMock.callArgs, &mm_params)
	mmGetMessagesByChatId.GetMessagesByChatIdMock.mutex.Unlock()

	for _, e := range mmGetMessagesByChatId.GetMessagesByChatIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation.params
		mm_got := MessageRepositoryMockGetMessagesByChatIdParams{ctx, chatId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMessagesByChatId.t.Errorf("MessageRepositoryMock.GetMessagesByChatId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMessagesByChatId.t.Fatal("No results are set for the MessageRepositoryMock.GetMessagesByChatId")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmGetMessagesByChatId.funcGetMessagesByChatId != nil {
		return mmGetMessagesByChatId.funcGetMessagesByChatId(ctx, chatId)
	}
	mmGetMessagesByChatId.t.Fatalf("Unexpected call to MessageRepositoryMock.GetMessagesByChatId. %v %v", ctx, chatId)
	return
}

// GetMessagesByChatIdAfterCounter returns a count of finished MessageRepositoryMock.GetMessagesByChatId invocations
func (mmGetMessagesByChatId *MessageRepositoryMock) GetMessagesByChatIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessagesByChatId.afterGetMessagesByChatIdCounter)
}

// GetMessagesByChatIdBeforeCounter returns a count of MessageRepositoryMock.GetMessagesByChatId invocations
func (mmGetMessagesByChatId *MessageRepositoryMock) GetMessagesByChatIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessagesByChatId.beforeGetMessagesByChatIdCounter)
}

// Calls returns a list of arguments used in each call to MessageRepositoryMock.GetMessagesByChatId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMessagesByChatId *mMessageRepositoryMockGetMessagesByChatId) Calls() []*MessageRepositoryMockGetMessagesByChatIdParams {
	mmGetMessagesByChatId.mutex.RLock()

	argCopy := make([]*MessageRepositoryMockGetMessagesByChatIdParams, len(mmGetMessagesByChatId.callArgs))
	copy(argCopy, mmGetMessagesByChatId.callArgs)

	mmGetMessagesByChatId.mutex.RUnlock()

	return argCopy
}

// MinimockGetMessagesByChatIdDone returns true if the count of the GetMessagesByChatId invocations corresponds
// the number of defined expectations
func (m *MessageRepositoryMock) MinimockGetMessagesByChatIdDone() bool {
	for _, e := range m.GetMessagesByChatIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMessagesByChatIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMessagesByChatId != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMessagesByChatIdInspect logs each unmet expectation
func (m *MessageRepositoryMock) MinimockGetMessagesByChatIdInspect() {
	for _, e := range m.GetMessagesByChatIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageRepositoryMock.GetMessagesByChatId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMessagesByChatIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		if m.GetMessagesByChatIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageRepositoryMock.GetMessagesByChatId")
		} else {
			m.t.Errorf("Expected call to MessageRepositoryMock.GetMessagesByChatId with params: %#v", *m.GetMessagesByChatIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMessagesByChatId != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		m.t.Error("Expected call to MessageRepositoryMock.GetMessagesByChatId")
	}
}

type mMessageRepositoryMockSaveMessage struct {
	mock               *MessageRepositoryMock
	defaultExpectation *MessageRepositoryMockSaveMessageExpectation
	expectations       []*MessageRepositoryMockSaveMessageExpectation

	callArgs []*MessageRepositoryMockSaveMessageParams
	mutex    sync.RWMutex
}

// MessageRepositoryMockSaveMessageExpectation specifies expectation struct of the MessageRepository.SaveMessage
type MessageRepositoryMockSaveMessageExpectation struct {
	mock    *MessageRepositoryMock
	params  *MessageRepositoryMockSaveMessageParams
	results *MessageRepositoryMockSaveMessageResults
	Counter uint64
}

// MessageRepositoryMockSaveMessageParams contains parameters of the MessageRepository.SaveMessage
type MessageRepositoryMockSaveMessageParams struct {
	ctx context.Context
	req dto.SendMessageRequest
}

// MessageRepositoryMockSaveMessageResults contains results of the MessageRepository.SaveMessage
type MessageRepositoryMockSaveMessageResults struct {
	m1  domain.Message
	err error
}

// Expect sets up expected params for MessageRepository.SaveMessage
func (mmSaveMessage *mMessageRepositoryMockSaveMessage) Expect(ctx context.Context, req dto.SendMessageRequest) *mMessageRepositoryMockSaveMessage {
	if mmSaveMessage.mock.funcSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("MessageRepositoryMock.SaveMessage mock is already set by Set")
	}

	if mmSaveMessage.defaultExpectation == nil {
		mmSaveMessage.defaultExpectation = &MessageRepositoryMockSaveMessageExpectation{}
	}

	mmSaveMessage.defaultExpectation.params = &MessageRepositoryMockSaveMessageParams{ctx, req}
	for _, e := range mmSaveMessage.expectations {
		if minimock.Equal(e.params, mmSaveMessage.defaultExpectation.params) {
			mmSaveMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveMessage.defaultExpectation.params)
		}
	}

	return mmSaveMessage
}

// Inspect accepts an inspector function that has same arguments as the MessageRepository.SaveMessage
func (mmSaveMessage *mMessageRepositoryMockSaveMessage) Inspect(f func(ctx context.Context, req dto.SendMessageRequest)) *mMessageRepositoryMockSaveMessage {
	if mmSaveMessage.mock.inspectFuncSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("Inspect function is already set for MessageRepositoryMock.SaveMessage")
	}

	mmSaveMessage.mock.inspectFuncSaveMessage = f

	return mmSaveMessage
}

// Return sets up results that will be returned by MessageRepository.SaveMessage
func (mmSaveMessage *mMessageRepositoryMockSaveMessage) Return(m1 domain.Message, err error) *MessageRepositoryMock {
	if mmSaveMessage.mock.funcSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("MessageRepositoryMock.SaveMessage mock is already set by Set")
	}

	if mmSaveMessage.defaultExpectation == nil {
		mmSaveMessage.defaultExpectation = &MessageRepositoryMockSaveMessageExpectation{mock: mmSaveMessage.mock}
	}
	mmSaveMessage.defaultExpectation.results = &MessageRepositoryMockSaveMessageResults{m1, err}
	return mmSaveMessage.mock
}

// Set uses given function f to mock the MessageRepository.SaveMessage method
func (mmSaveMessage *mMessageRepositoryMockSaveMessage) Set(f func(ctx context.Context, req dto.SendMessageRequest) (m1 domain.Message, err error)) *MessageRepositoryMock {
	if mmSaveMessage.defaultExpectation != nil {
		mmSaveMessage.mock.t.Fatalf("Default expectation is already set for the MessageRepository.SaveMessage method")
	}

	if len(mmSaveMessage.expectations) > 0 {
		mmSaveMessage.mock.t.Fatalf("Some expectations are already set for the MessageRepository.SaveMessage method")
	}

	mmSaveMessage.mock.funcSaveMessage = f
	return mmSaveMessage.mock
}

// When sets expectation for the MessageRepository.SaveMessage which will trigger the result defined by the following
// Then helper
func (mmSaveMessage *mMessageRepositoryMockSaveMessage) When(ctx context.Context, req dto.SendMessageRequest) *MessageRepositoryMockSaveMessageExpectation {
	if mmSaveMessage.mock.funcSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("MessageRepositoryMock.SaveMessage mock is already set by Set")
	}

	expectation := &MessageRepositoryMockSaveMessageExpectation{
		mock:   mmSaveMessage.mock,
		params: &MessageRepositoryMockSaveMessageParams{ctx, req},
	}
	mmSaveMessage.expectations = append(mmSaveMessage.expectations, expectation)
	return expectation
}

// Then sets up MessageRepository.SaveMessage return parameters for the expectation previously defined by the When method
func (e *MessageRepositoryMockSaveMessageExpectation) Then(m1 domain.Message, err error) *MessageRepositoryMock {
	e.results = &MessageRepositoryMockSaveMessageResults{m1, err}
	return e.mock
}

// SaveMessage implements repository.MessageRepository
func (mmSaveMessage *MessageRepositoryMock) SaveMessage(ctx context.Context, req dto.SendMessageRequest) (m1 domain.Message, err error) {
	mm_atomic.AddUint64(&mmSaveMessage.beforeSaveMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveMessage.afterSaveMessageCounter, 1)

	if mmSaveMessage.inspectFuncSaveMessage != nil {
		mmSaveMessage.inspectFuncSaveMessage(ctx, req)
	}

	mm_params := MessageRepositoryMockSaveMessageParams{ctx, req}

	// Record call args
	mmSaveMessage.SaveMessageMock.mutex.Lock()
	mmSaveMessage.SaveMessageMock.callArgs = append(mmSaveMessage.SaveMessageMock.callArgs, &mm_params)
	mmSaveMessage.SaveMessageMock.mutex.Unlock()

	for _, e := range mmSaveMessage.SaveMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmSaveMessage.SaveMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveMessage.SaveMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveMessage.SaveMessageMock.defaultExpectation.params
		mm_got := MessageRepositoryMockSaveMessageParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveMessage.t.Errorf("MessageRepositoryMock.SaveMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveMessage.SaveMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveMessage.t.Fatal("No results are set for the MessageRepositoryMock.SaveMessage")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmSaveMessage.funcSaveMessage != nil {
		return mmSaveMessage.funcSaveMessage(ctx, req)
	}
	mmSaveMessage.t.Fatalf("Unexpected call to MessageRepositoryMock.SaveMessage. %v %v", ctx, req)
	return
}

// SaveMessageAfterCounter returns a count of finished MessageRepositoryMock.SaveMessage invocations
func (mmSaveMessage *MessageRepositoryMock) SaveMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveMessage.afterSaveMessageCounter)
}

// SaveMessageBeforeCounter returns a count of MessageRepositoryMock.SaveMessage invocations
func (mmSaveMessage *MessageRepositoryMock) SaveMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveMessage.beforeSaveMessageCounter)
}

// Calls returns a list of arguments used in each call to MessageRepositoryMock.SaveMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveMessage *mMessageRepositoryMockSaveMessage) Calls() []*MessageRepositoryMockSaveMessageParams {
	mmSaveMessage.mutex.RLock()

	argCopy := make([]*MessageRepositoryMockSaveMessageParams, len(mmSaveMessage.callArgs))
	copy(argCopy, mmSaveMessage.callArgs)

	mmSaveMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSaveMessageDone returns true if the count of the SaveMessage invocations corresponds
// the number of defined expectations
func (m *MessageRepositoryMock) MinimockSaveMessageDone() bool {
	for _, e := range m.SaveMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveMessage != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveMessageInspect logs each unmet expectation
func (m *MessageRepositoryMock) MinimockSaveMessageInspect() {
	for _, e := range m.SaveMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageRepositoryMock.SaveMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		if m.SaveMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageRepositoryMock.SaveMessage")
		} else {
			m.t.Errorf("Expected call to MessageRepositoryMock.SaveMessage with params: %#v", *m.SaveMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveMessage != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		m.t.Error("Expected call to MessageRepositoryMock.SaveMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteInspect()

			m.MinimockGetMessagesByChatIdInspect()

			m.MinimockSaveMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessageRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockGetMessagesByChatIdDone() &&
		m.MinimockSaveMessageDone()
}
