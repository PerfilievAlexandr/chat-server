// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/PerfilievAlexandr/chat-server/internal/repository.ChatRepository -o chat_repository_minimock.go -n ChatRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/PerfilievAlexandr/chat-server/internal/api/grpc/chat/dto"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ChatRepositoryMock implements repository.ChatRepository
type ChatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIsExists          func(ctx context.Context, chatId uuid.UUID) (b1 bool, err error)
	inspectFuncIsExists   func(ctx context.Context, chatId uuid.UUID)
	afterIsExistsCounter  uint64
	beforeIsExistsCounter uint64
	IsExistsMock          mChatRepositoryMockIsExists

	funcSaveChat          func(ctx context.Context, req dto.CreateChatRequest) (u1 uuid.UUID, err error)
	inspectFuncSaveChat   func(ctx context.Context, req dto.CreateChatRequest)
	afterSaveChatCounter  uint64
	beforeSaveChatCounter uint64
	SaveChatMock          mChatRepositoryMockSaveChat
}

// NewChatRepositoryMock returns a mock for repository.ChatRepository
func NewChatRepositoryMock(t minimock.Tester) *ChatRepositoryMock {
	m := &ChatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsExistsMock = mChatRepositoryMockIsExists{mock: m}
	m.IsExistsMock.callArgs = []*ChatRepositoryMockIsExistsParams{}

	m.SaveChatMock = mChatRepositoryMockSaveChat{mock: m}
	m.SaveChatMock.callArgs = []*ChatRepositoryMockSaveChatParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryMockIsExists struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockIsExistsExpectation
	expectations       []*ChatRepositoryMockIsExistsExpectation

	callArgs []*ChatRepositoryMockIsExistsParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockIsExistsExpectation specifies expectation struct of the ChatRepository.IsExists
type ChatRepositoryMockIsExistsExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockIsExistsParams
	results *ChatRepositoryMockIsExistsResults
	Counter uint64
}

// ChatRepositoryMockIsExistsParams contains parameters of the ChatRepository.IsExists
type ChatRepositoryMockIsExistsParams struct {
	ctx    context.Context
	chatId uuid.UUID
}

// ChatRepositoryMockIsExistsResults contains results of the ChatRepository.IsExists
type ChatRepositoryMockIsExistsResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for ChatRepository.IsExists
func (mmIsExists *mChatRepositoryMockIsExists) Expect(ctx context.Context, chatId uuid.UUID) *mChatRepositoryMockIsExists {
	if mmIsExists.mock.funcIsExists != nil {
		mmIsExists.mock.t.Fatalf("ChatRepositoryMock.IsExists mock is already set by Set")
	}

	if mmIsExists.defaultExpectation == nil {
		mmIsExists.defaultExpectation = &ChatRepositoryMockIsExistsExpectation{}
	}

	mmIsExists.defaultExpectation.params = &ChatRepositoryMockIsExistsParams{ctx, chatId}
	for _, e := range mmIsExists.expectations {
		if minimock.Equal(e.params, mmIsExists.defaultExpectation.params) {
			mmIsExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsExists.defaultExpectation.params)
		}
	}

	return mmIsExists
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.IsExists
func (mmIsExists *mChatRepositoryMockIsExists) Inspect(f func(ctx context.Context, chatId uuid.UUID)) *mChatRepositoryMockIsExists {
	if mmIsExists.mock.inspectFuncIsExists != nil {
		mmIsExists.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.IsExists")
	}

	mmIsExists.mock.inspectFuncIsExists = f

	return mmIsExists
}

// Return sets up results that will be returned by ChatRepository.IsExists
func (mmIsExists *mChatRepositoryMockIsExists) Return(b1 bool, err error) *ChatRepositoryMock {
	if mmIsExists.mock.funcIsExists != nil {
		mmIsExists.mock.t.Fatalf("ChatRepositoryMock.IsExists mock is already set by Set")
	}

	if mmIsExists.defaultExpectation == nil {
		mmIsExists.defaultExpectation = &ChatRepositoryMockIsExistsExpectation{mock: mmIsExists.mock}
	}
	mmIsExists.defaultExpectation.results = &ChatRepositoryMockIsExistsResults{b1, err}
	return mmIsExists.mock
}

// Set uses given function f to mock the ChatRepository.IsExists method
func (mmIsExists *mChatRepositoryMockIsExists) Set(f func(ctx context.Context, chatId uuid.UUID) (b1 bool, err error)) *ChatRepositoryMock {
	if mmIsExists.defaultExpectation != nil {
		mmIsExists.mock.t.Fatalf("Default expectation is already set for the ChatRepository.IsExists method")
	}

	if len(mmIsExists.expectations) > 0 {
		mmIsExists.mock.t.Fatalf("Some expectations are already set for the ChatRepository.IsExists method")
	}

	mmIsExists.mock.funcIsExists = f
	return mmIsExists.mock
}

// When sets expectation for the ChatRepository.IsExists which will trigger the result defined by the following
// Then helper
func (mmIsExists *mChatRepositoryMockIsExists) When(ctx context.Context, chatId uuid.UUID) *ChatRepositoryMockIsExistsExpectation {
	if mmIsExists.mock.funcIsExists != nil {
		mmIsExists.mock.t.Fatalf("ChatRepositoryMock.IsExists mock is already set by Set")
	}

	expectation := &ChatRepositoryMockIsExistsExpectation{
		mock:   mmIsExists.mock,
		params: &ChatRepositoryMockIsExistsParams{ctx, chatId},
	}
	mmIsExists.expectations = append(mmIsExists.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.IsExists return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockIsExistsExpectation) Then(b1 bool, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockIsExistsResults{b1, err}
	return e.mock
}

// IsExists implements repository.ChatRepository
func (mmIsExists *ChatRepositoryMock) IsExists(ctx context.Context, chatId uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsExists.beforeIsExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmIsExists.afterIsExistsCounter, 1)

	if mmIsExists.inspectFuncIsExists != nil {
		mmIsExists.inspectFuncIsExists(ctx, chatId)
	}

	mm_params := ChatRepositoryMockIsExistsParams{ctx, chatId}

	// Record call args
	mmIsExists.IsExistsMock.mutex.Lock()
	mmIsExists.IsExistsMock.callArgs = append(mmIsExists.IsExistsMock.callArgs, &mm_params)
	mmIsExists.IsExistsMock.mutex.Unlock()

	for _, e := range mmIsExists.IsExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsExists.IsExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsExists.IsExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmIsExists.IsExistsMock.defaultExpectation.params
		mm_got := ChatRepositoryMockIsExistsParams{ctx, chatId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsExists.t.Errorf("ChatRepositoryMock.IsExists got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsExists.IsExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmIsExists.t.Fatal("No results are set for the ChatRepositoryMock.IsExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsExists.funcIsExists != nil {
		return mmIsExists.funcIsExists(ctx, chatId)
	}
	mmIsExists.t.Fatalf("Unexpected call to ChatRepositoryMock.IsExists. %v %v", ctx, chatId)
	return
}

// IsExistsAfterCounter returns a count of finished ChatRepositoryMock.IsExists invocations
func (mmIsExists *ChatRepositoryMock) IsExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsExists.afterIsExistsCounter)
}

// IsExistsBeforeCounter returns a count of ChatRepositoryMock.IsExists invocations
func (mmIsExists *ChatRepositoryMock) IsExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsExists.beforeIsExistsCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.IsExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsExists *mChatRepositoryMockIsExists) Calls() []*ChatRepositoryMockIsExistsParams {
	mmIsExists.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockIsExistsParams, len(mmIsExists.callArgs))
	copy(argCopy, mmIsExists.callArgs)

	mmIsExists.mutex.RUnlock()

	return argCopy
}

// MinimockIsExistsDone returns true if the count of the IsExists invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockIsExistsDone() bool {
	for _, e := range m.IsExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsExistsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsExists != nil && mm_atomic.LoadUint64(&m.afterIsExistsCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsExistsInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockIsExistsInspect() {
	for _, e := range m.IsExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.IsExists with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsExistsCounter) < 1 {
		if m.IsExistsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.IsExists")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.IsExists with params: %#v", *m.IsExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsExists != nil && mm_atomic.LoadUint64(&m.afterIsExistsCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.IsExists")
	}
}

type mChatRepositoryMockSaveChat struct {
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockSaveChatExpectation
	expectations       []*ChatRepositoryMockSaveChatExpectation

	callArgs []*ChatRepositoryMockSaveChatParams
	mutex    sync.RWMutex
}

// ChatRepositoryMockSaveChatExpectation specifies expectation struct of the ChatRepository.SaveChat
type ChatRepositoryMockSaveChatExpectation struct {
	mock    *ChatRepositoryMock
	params  *ChatRepositoryMockSaveChatParams
	results *ChatRepositoryMockSaveChatResults
	Counter uint64
}

// ChatRepositoryMockSaveChatParams contains parameters of the ChatRepository.SaveChat
type ChatRepositoryMockSaveChatParams struct {
	ctx context.Context
	req dto.CreateChatRequest
}

// ChatRepositoryMockSaveChatResults contains results of the ChatRepository.SaveChat
type ChatRepositoryMockSaveChatResults struct {
	u1  uuid.UUID
	err error
}

// Expect sets up expected params for ChatRepository.SaveChat
func (mmSaveChat *mChatRepositoryMockSaveChat) Expect(ctx context.Context, req dto.CreateChatRequest) *mChatRepositoryMockSaveChat {
	if mmSaveChat.mock.funcSaveChat != nil {
		mmSaveChat.mock.t.Fatalf("ChatRepositoryMock.SaveChat mock is already set by Set")
	}

	if mmSaveChat.defaultExpectation == nil {
		mmSaveChat.defaultExpectation = &ChatRepositoryMockSaveChatExpectation{}
	}

	mmSaveChat.defaultExpectation.params = &ChatRepositoryMockSaveChatParams{ctx, req}
	for _, e := range mmSaveChat.expectations {
		if minimock.Equal(e.params, mmSaveChat.defaultExpectation.params) {
			mmSaveChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveChat.defaultExpectation.params)
		}
	}

	return mmSaveChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.SaveChat
func (mmSaveChat *mChatRepositoryMockSaveChat) Inspect(f func(ctx context.Context, req dto.CreateChatRequest)) *mChatRepositoryMockSaveChat {
	if mmSaveChat.mock.inspectFuncSaveChat != nil {
		mmSaveChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.SaveChat")
	}

	mmSaveChat.mock.inspectFuncSaveChat = f

	return mmSaveChat
}

// Return sets up results that will be returned by ChatRepository.SaveChat
func (mmSaveChat *mChatRepositoryMockSaveChat) Return(u1 uuid.UUID, err error) *ChatRepositoryMock {
	if mmSaveChat.mock.funcSaveChat != nil {
		mmSaveChat.mock.t.Fatalf("ChatRepositoryMock.SaveChat mock is already set by Set")
	}

	if mmSaveChat.defaultExpectation == nil {
		mmSaveChat.defaultExpectation = &ChatRepositoryMockSaveChatExpectation{mock: mmSaveChat.mock}
	}
	mmSaveChat.defaultExpectation.results = &ChatRepositoryMockSaveChatResults{u1, err}
	return mmSaveChat.mock
}

// Set uses given function f to mock the ChatRepository.SaveChat method
func (mmSaveChat *mChatRepositoryMockSaveChat) Set(f func(ctx context.Context, req dto.CreateChatRequest) (u1 uuid.UUID, err error)) *ChatRepositoryMock {
	if mmSaveChat.defaultExpectation != nil {
		mmSaveChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.SaveChat method")
	}

	if len(mmSaveChat.expectations) > 0 {
		mmSaveChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.SaveChat method")
	}

	mmSaveChat.mock.funcSaveChat = f
	return mmSaveChat.mock
}

// When sets expectation for the ChatRepository.SaveChat which will trigger the result defined by the following
// Then helper
func (mmSaveChat *mChatRepositoryMockSaveChat) When(ctx context.Context, req dto.CreateChatRequest) *ChatRepositoryMockSaveChatExpectation {
	if mmSaveChat.mock.funcSaveChat != nil {
		mmSaveChat.mock.t.Fatalf("ChatRepositoryMock.SaveChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockSaveChatExpectation{
		mock:   mmSaveChat.mock,
		params: &ChatRepositoryMockSaveChatParams{ctx, req},
	}
	mmSaveChat.expectations = append(mmSaveChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.SaveChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockSaveChatExpectation) Then(u1 uuid.UUID, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockSaveChatResults{u1, err}
	return e.mock
}

// SaveChat implements repository.ChatRepository
func (mmSaveChat *ChatRepositoryMock) SaveChat(ctx context.Context, req dto.CreateChatRequest) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmSaveChat.beforeSaveChatCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveChat.afterSaveChatCounter, 1)

	if mmSaveChat.inspectFuncSaveChat != nil {
		mmSaveChat.inspectFuncSaveChat(ctx, req)
	}

	mm_params := ChatRepositoryMockSaveChatParams{ctx, req}

	// Record call args
	mmSaveChat.SaveChatMock.mutex.Lock()
	mmSaveChat.SaveChatMock.callArgs = append(mmSaveChat.SaveChatMock.callArgs, &mm_params)
	mmSaveChat.SaveChatMock.mutex.Unlock()

	for _, e := range mmSaveChat.SaveChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmSaveChat.SaveChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveChat.SaveChatMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveChat.SaveChatMock.defaultExpectation.params
		mm_got := ChatRepositoryMockSaveChatParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveChat.t.Errorf("ChatRepositoryMock.SaveChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveChat.SaveChatMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveChat.t.Fatal("No results are set for the ChatRepositoryMock.SaveChat")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmSaveChat.funcSaveChat != nil {
		return mmSaveChat.funcSaveChat(ctx, req)
	}
	mmSaveChat.t.Fatalf("Unexpected call to ChatRepositoryMock.SaveChat. %v %v", ctx, req)
	return
}

// SaveChatAfterCounter returns a count of finished ChatRepositoryMock.SaveChat invocations
func (mmSaveChat *ChatRepositoryMock) SaveChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveChat.afterSaveChatCounter)
}

// SaveChatBeforeCounter returns a count of ChatRepositoryMock.SaveChat invocations
func (mmSaveChat *ChatRepositoryMock) SaveChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveChat.beforeSaveChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.SaveChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveChat *mChatRepositoryMockSaveChat) Calls() []*ChatRepositoryMockSaveChatParams {
	mmSaveChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockSaveChatParams, len(mmSaveChat.callArgs))
	copy(argCopy, mmSaveChat.callArgs)

	mmSaveChat.mutex.RUnlock()

	return argCopy
}

// MinimockSaveChatDone returns true if the count of the SaveChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockSaveChatDone() bool {
	for _, e := range m.SaveChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveChat != nil && mm_atomic.LoadUint64(&m.afterSaveChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockSaveChatInspect() {
	for _, e := range m.SaveChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.SaveChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveChatCounter) < 1 {
		if m.SaveChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.SaveChat")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.SaveChat with params: %#v", *m.SaveChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveChat != nil && mm_atomic.LoadUint64(&m.afterSaveChatCounter) < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.SaveChat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIsExistsInspect()

			m.MinimockSaveChatInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsExistsDone() &&
		m.MinimockSaveChatDone()
}
