// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/PerfilievAlexandr/chat-server/internal/service.MessageService -o message_service_minimock.go -n MessageServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/PerfilievAlexandr/chat-server/internal/api/grpc/chat/dto"
	"github.com/PerfilievAlexandr/chat-server/internal/domain"
	"github.com/gojuno/minimock/v3"
)

// MessageServiceMock implements service.MessageService
type MessageServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetMessagesByChatId          func(ctx context.Context, chatId string) (ma1 []domain.Message, err error)
	inspectFuncGetMessagesByChatId   func(ctx context.Context, chatId string)
	afterGetMessagesByChatIdCounter  uint64
	beforeGetMessagesByChatIdCounter uint64
	GetMessagesByChatIdMock          mMessageServiceMockGetMessagesByChatId

	funcSaveMessage          func(ctx context.Context, req dto.SendMessageRequest) (m1 domain.Message, err error)
	inspectFuncSaveMessage   func(ctx context.Context, req dto.SendMessageRequest)
	afterSaveMessageCounter  uint64
	beforeSaveMessageCounter uint64
	SaveMessageMock          mMessageServiceMockSaveMessage
}

// NewMessageServiceMock returns a mock for service.MessageService
func NewMessageServiceMock(t minimock.Tester) *MessageServiceMock {
	m := &MessageServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetMessagesByChatIdMock = mMessageServiceMockGetMessagesByChatId{mock: m}
	m.GetMessagesByChatIdMock.callArgs = []*MessageServiceMockGetMessagesByChatIdParams{}

	m.SaveMessageMock = mMessageServiceMockSaveMessage{mock: m}
	m.SaveMessageMock.callArgs = []*MessageServiceMockSaveMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMessageServiceMockGetMessagesByChatId struct {
	mock               *MessageServiceMock
	defaultExpectation *MessageServiceMockGetMessagesByChatIdExpectation
	expectations       []*MessageServiceMockGetMessagesByChatIdExpectation

	callArgs []*MessageServiceMockGetMessagesByChatIdParams
	mutex    sync.RWMutex
}

// MessageServiceMockGetMessagesByChatIdExpectation specifies expectation struct of the MessageService.GetMessagesByChatId
type MessageServiceMockGetMessagesByChatIdExpectation struct {
	mock    *MessageServiceMock
	params  *MessageServiceMockGetMessagesByChatIdParams
	results *MessageServiceMockGetMessagesByChatIdResults
	Counter uint64
}

// MessageServiceMockGetMessagesByChatIdParams contains parameters of the MessageService.GetMessagesByChatId
type MessageServiceMockGetMessagesByChatIdParams struct {
	ctx    context.Context
	chatId string
}

// MessageServiceMockGetMessagesByChatIdResults contains results of the MessageService.GetMessagesByChatId
type MessageServiceMockGetMessagesByChatIdResults struct {
	ma1 []domain.Message
	err error
}

// Expect sets up expected params for MessageService.GetMessagesByChatId
func (mmGetMessagesByChatId *mMessageServiceMockGetMessagesByChatId) Expect(ctx context.Context, chatId string) *mMessageServiceMockGetMessagesByChatId {
	if mmGetMessagesByChatId.mock.funcGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("MessageServiceMock.GetMessagesByChatId mock is already set by Set")
	}

	if mmGetMessagesByChatId.defaultExpectation == nil {
		mmGetMessagesByChatId.defaultExpectation = &MessageServiceMockGetMessagesByChatIdExpectation{}
	}

	mmGetMessagesByChatId.defaultExpectation.params = &MessageServiceMockGetMessagesByChatIdParams{ctx, chatId}
	for _, e := range mmGetMessagesByChatId.expectations {
		if minimock.Equal(e.params, mmGetMessagesByChatId.defaultExpectation.params) {
			mmGetMessagesByChatId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMessagesByChatId.defaultExpectation.params)
		}
	}

	return mmGetMessagesByChatId
}

// Inspect accepts an inspector function that has same arguments as the MessageService.GetMessagesByChatId
func (mmGetMessagesByChatId *mMessageServiceMockGetMessagesByChatId) Inspect(f func(ctx context.Context, chatId string)) *mMessageServiceMockGetMessagesByChatId {
	if mmGetMessagesByChatId.mock.inspectFuncGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("Inspect function is already set for MessageServiceMock.GetMessagesByChatId")
	}

	mmGetMessagesByChatId.mock.inspectFuncGetMessagesByChatId = f

	return mmGetMessagesByChatId
}

// Return sets up results that will be returned by MessageService.GetMessagesByChatId
func (mmGetMessagesByChatId *mMessageServiceMockGetMessagesByChatId) Return(ma1 []domain.Message, err error) *MessageServiceMock {
	if mmGetMessagesByChatId.mock.funcGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("MessageServiceMock.GetMessagesByChatId mock is already set by Set")
	}

	if mmGetMessagesByChatId.defaultExpectation == nil {
		mmGetMessagesByChatId.defaultExpectation = &MessageServiceMockGetMessagesByChatIdExpectation{mock: mmGetMessagesByChatId.mock}
	}
	mmGetMessagesByChatId.defaultExpectation.results = &MessageServiceMockGetMessagesByChatIdResults{ma1, err}
	return mmGetMessagesByChatId.mock
}

// Set uses given function f to mock the MessageService.GetMessagesByChatId method
func (mmGetMessagesByChatId *mMessageServiceMockGetMessagesByChatId) Set(f func(ctx context.Context, chatId string) (ma1 []domain.Message, err error)) *MessageServiceMock {
	if mmGetMessagesByChatId.defaultExpectation != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("Default expectation is already set for the MessageService.GetMessagesByChatId method")
	}

	if len(mmGetMessagesByChatId.expectations) > 0 {
		mmGetMessagesByChatId.mock.t.Fatalf("Some expectations are already set for the MessageService.GetMessagesByChatId method")
	}

	mmGetMessagesByChatId.mock.funcGetMessagesByChatId = f
	return mmGetMessagesByChatId.mock
}

// When sets expectation for the MessageService.GetMessagesByChatId which will trigger the result defined by the following
// Then helper
func (mmGetMessagesByChatId *mMessageServiceMockGetMessagesByChatId) When(ctx context.Context, chatId string) *MessageServiceMockGetMessagesByChatIdExpectation {
	if mmGetMessagesByChatId.mock.funcGetMessagesByChatId != nil {
		mmGetMessagesByChatId.mock.t.Fatalf("MessageServiceMock.GetMessagesByChatId mock is already set by Set")
	}

	expectation := &MessageServiceMockGetMessagesByChatIdExpectation{
		mock:   mmGetMessagesByChatId.mock,
		params: &MessageServiceMockGetMessagesByChatIdParams{ctx, chatId},
	}
	mmGetMessagesByChatId.expectations = append(mmGetMessagesByChatId.expectations, expectation)
	return expectation
}

// Then sets up MessageService.GetMessagesByChatId return parameters for the expectation previously defined by the When method
func (e *MessageServiceMockGetMessagesByChatIdExpectation) Then(ma1 []domain.Message, err error) *MessageServiceMock {
	e.results = &MessageServiceMockGetMessagesByChatIdResults{ma1, err}
	return e.mock
}

// GetMessagesByChatId implements service.MessageService
func (mmGetMessagesByChatId *MessageServiceMock) GetMessagesByChatId(ctx context.Context, chatId string) (ma1 []domain.Message, err error) {
	mm_atomic.AddUint64(&mmGetMessagesByChatId.beforeGetMessagesByChatIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMessagesByChatId.afterGetMessagesByChatIdCounter, 1)

	if mmGetMessagesByChatId.inspectFuncGetMessagesByChatId != nil {
		mmGetMessagesByChatId.inspectFuncGetMessagesByChatId(ctx, chatId)
	}

	mm_params := MessageServiceMockGetMessagesByChatIdParams{ctx, chatId}

	// Record call args
	mmGetMessagesByChatId.GetMessagesByChatIdMock.mutex.Lock()
	mmGetMessagesByChatId.GetMessagesByChatIdMock.callArgs = append(mmGetMessagesByChatId.GetMessagesByChatIdMock.callArgs, &mm_params)
	mmGetMessagesByChatId.GetMessagesByChatIdMock.mutex.Unlock()

	for _, e := range mmGetMessagesByChatId.GetMessagesByChatIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation.params
		mm_got := MessageServiceMockGetMessagesByChatIdParams{ctx, chatId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMessagesByChatId.t.Errorf("MessageServiceMock.GetMessagesByChatId got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMessagesByChatId.GetMessagesByChatIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMessagesByChatId.t.Fatal("No results are set for the MessageServiceMock.GetMessagesByChatId")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmGetMessagesByChatId.funcGetMessagesByChatId != nil {
		return mmGetMessagesByChatId.funcGetMessagesByChatId(ctx, chatId)
	}
	mmGetMessagesByChatId.t.Fatalf("Unexpected call to MessageServiceMock.GetMessagesByChatId. %v %v", ctx, chatId)
	return
}

// GetMessagesByChatIdAfterCounter returns a count of finished MessageServiceMock.GetMessagesByChatId invocations
func (mmGetMessagesByChatId *MessageServiceMock) GetMessagesByChatIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessagesByChatId.afterGetMessagesByChatIdCounter)
}

// GetMessagesByChatIdBeforeCounter returns a count of MessageServiceMock.GetMessagesByChatId invocations
func (mmGetMessagesByChatId *MessageServiceMock) GetMessagesByChatIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessagesByChatId.beforeGetMessagesByChatIdCounter)
}

// Calls returns a list of arguments used in each call to MessageServiceMock.GetMessagesByChatId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMessagesByChatId *mMessageServiceMockGetMessagesByChatId) Calls() []*MessageServiceMockGetMessagesByChatIdParams {
	mmGetMessagesByChatId.mutex.RLock()

	argCopy := make([]*MessageServiceMockGetMessagesByChatIdParams, len(mmGetMessagesByChatId.callArgs))
	copy(argCopy, mmGetMessagesByChatId.callArgs)

	mmGetMessagesByChatId.mutex.RUnlock()

	return argCopy
}

// MinimockGetMessagesByChatIdDone returns true if the count of the GetMessagesByChatId invocations corresponds
// the number of defined expectations
func (m *MessageServiceMock) MinimockGetMessagesByChatIdDone() bool {
	for _, e := range m.GetMessagesByChatIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMessagesByChatIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMessagesByChatId != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMessagesByChatIdInspect logs each unmet expectation
func (m *MessageServiceMock) MinimockGetMessagesByChatIdInspect() {
	for _, e := range m.GetMessagesByChatIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageServiceMock.GetMessagesByChatId with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMessagesByChatIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		if m.GetMessagesByChatIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageServiceMock.GetMessagesByChatId")
		} else {
			m.t.Errorf("Expected call to MessageServiceMock.GetMessagesByChatId with params: %#v", *m.GetMessagesByChatIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMessagesByChatId != nil && mm_atomic.LoadUint64(&m.afterGetMessagesByChatIdCounter) < 1 {
		m.t.Error("Expected call to MessageServiceMock.GetMessagesByChatId")
	}
}

type mMessageServiceMockSaveMessage struct {
	mock               *MessageServiceMock
	defaultExpectation *MessageServiceMockSaveMessageExpectation
	expectations       []*MessageServiceMockSaveMessageExpectation

	callArgs []*MessageServiceMockSaveMessageParams
	mutex    sync.RWMutex
}

// MessageServiceMockSaveMessageExpectation specifies expectation struct of the MessageService.SaveMessage
type MessageServiceMockSaveMessageExpectation struct {
	mock    *MessageServiceMock
	params  *MessageServiceMockSaveMessageParams
	results *MessageServiceMockSaveMessageResults
	Counter uint64
}

// MessageServiceMockSaveMessageParams contains parameters of the MessageService.SaveMessage
type MessageServiceMockSaveMessageParams struct {
	ctx context.Context
	req dto.SendMessageRequest
}

// MessageServiceMockSaveMessageResults contains results of the MessageService.SaveMessage
type MessageServiceMockSaveMessageResults struct {
	m1  domain.Message
	err error
}

// Expect sets up expected params for MessageService.SaveMessage
func (mmSaveMessage *mMessageServiceMockSaveMessage) Expect(ctx context.Context, req dto.SendMessageRequest) *mMessageServiceMockSaveMessage {
	if mmSaveMessage.mock.funcSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("MessageServiceMock.SaveMessage mock is already set by Set")
	}

	if mmSaveMessage.defaultExpectation == nil {
		mmSaveMessage.defaultExpectation = &MessageServiceMockSaveMessageExpectation{}
	}

	mmSaveMessage.defaultExpectation.params = &MessageServiceMockSaveMessageParams{ctx, req}
	for _, e := range mmSaveMessage.expectations {
		if minimock.Equal(e.params, mmSaveMessage.defaultExpectation.params) {
			mmSaveMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveMessage.defaultExpectation.params)
		}
	}

	return mmSaveMessage
}

// Inspect accepts an inspector function that has same arguments as the MessageService.SaveMessage
func (mmSaveMessage *mMessageServiceMockSaveMessage) Inspect(f func(ctx context.Context, req dto.SendMessageRequest)) *mMessageServiceMockSaveMessage {
	if mmSaveMessage.mock.inspectFuncSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("Inspect function is already set for MessageServiceMock.SaveMessage")
	}

	mmSaveMessage.mock.inspectFuncSaveMessage = f

	return mmSaveMessage
}

// Return sets up results that will be returned by MessageService.SaveMessage
func (mmSaveMessage *mMessageServiceMockSaveMessage) Return(m1 domain.Message, err error) *MessageServiceMock {
	if mmSaveMessage.mock.funcSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("MessageServiceMock.SaveMessage mock is already set by Set")
	}

	if mmSaveMessage.defaultExpectation == nil {
		mmSaveMessage.defaultExpectation = &MessageServiceMockSaveMessageExpectation{mock: mmSaveMessage.mock}
	}
	mmSaveMessage.defaultExpectation.results = &MessageServiceMockSaveMessageResults{m1, err}
	return mmSaveMessage.mock
}

// Set uses given function f to mock the MessageService.SaveMessage method
func (mmSaveMessage *mMessageServiceMockSaveMessage) Set(f func(ctx context.Context, req dto.SendMessageRequest) (m1 domain.Message, err error)) *MessageServiceMock {
	if mmSaveMessage.defaultExpectation != nil {
		mmSaveMessage.mock.t.Fatalf("Default expectation is already set for the MessageService.SaveMessage method")
	}

	if len(mmSaveMessage.expectations) > 0 {
		mmSaveMessage.mock.t.Fatalf("Some expectations are already set for the MessageService.SaveMessage method")
	}

	mmSaveMessage.mock.funcSaveMessage = f
	return mmSaveMessage.mock
}

// When sets expectation for the MessageService.SaveMessage which will trigger the result defined by the following
// Then helper
func (mmSaveMessage *mMessageServiceMockSaveMessage) When(ctx context.Context, req dto.SendMessageRequest) *MessageServiceMockSaveMessageExpectation {
	if mmSaveMessage.mock.funcSaveMessage != nil {
		mmSaveMessage.mock.t.Fatalf("MessageServiceMock.SaveMessage mock is already set by Set")
	}

	expectation := &MessageServiceMockSaveMessageExpectation{
		mock:   mmSaveMessage.mock,
		params: &MessageServiceMockSaveMessageParams{ctx, req},
	}
	mmSaveMessage.expectations = append(mmSaveMessage.expectations, expectation)
	return expectation
}

// Then sets up MessageService.SaveMessage return parameters for the expectation previously defined by the When method
func (e *MessageServiceMockSaveMessageExpectation) Then(m1 domain.Message, err error) *MessageServiceMock {
	e.results = &MessageServiceMockSaveMessageResults{m1, err}
	return e.mock
}

// SaveMessage implements service.MessageService
func (mmSaveMessage *MessageServiceMock) SaveMessage(ctx context.Context, req dto.SendMessageRequest) (m1 domain.Message, err error) {
	mm_atomic.AddUint64(&mmSaveMessage.beforeSaveMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveMessage.afterSaveMessageCounter, 1)

	if mmSaveMessage.inspectFuncSaveMessage != nil {
		mmSaveMessage.inspectFuncSaveMessage(ctx, req)
	}

	mm_params := MessageServiceMockSaveMessageParams{ctx, req}

	// Record call args
	mmSaveMessage.SaveMessageMock.mutex.Lock()
	mmSaveMessage.SaveMessageMock.callArgs = append(mmSaveMessage.SaveMessageMock.callArgs, &mm_params)
	mmSaveMessage.SaveMessageMock.mutex.Unlock()

	for _, e := range mmSaveMessage.SaveMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmSaveMessage.SaveMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveMessage.SaveMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveMessage.SaveMessageMock.defaultExpectation.params
		mm_got := MessageServiceMockSaveMessageParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveMessage.t.Errorf("MessageServiceMock.SaveMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveMessage.SaveMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveMessage.t.Fatal("No results are set for the MessageServiceMock.SaveMessage")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmSaveMessage.funcSaveMessage != nil {
		return mmSaveMessage.funcSaveMessage(ctx, req)
	}
	mmSaveMessage.t.Fatalf("Unexpected call to MessageServiceMock.SaveMessage. %v %v", ctx, req)
	return
}

// SaveMessageAfterCounter returns a count of finished MessageServiceMock.SaveMessage invocations
func (mmSaveMessage *MessageServiceMock) SaveMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveMessage.afterSaveMessageCounter)
}

// SaveMessageBeforeCounter returns a count of MessageServiceMock.SaveMessage invocations
func (mmSaveMessage *MessageServiceMock) SaveMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveMessage.beforeSaveMessageCounter)
}

// Calls returns a list of arguments used in each call to MessageServiceMock.SaveMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveMessage *mMessageServiceMockSaveMessage) Calls() []*MessageServiceMockSaveMessageParams {
	mmSaveMessage.mutex.RLock()

	argCopy := make([]*MessageServiceMockSaveMessageParams, len(mmSaveMessage.callArgs))
	copy(argCopy, mmSaveMessage.callArgs)

	mmSaveMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSaveMessageDone returns true if the count of the SaveMessage invocations corresponds
// the number of defined expectations
func (m *MessageServiceMock) MinimockSaveMessageDone() bool {
	for _, e := range m.SaveMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveMessage != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveMessageInspect logs each unmet expectation
func (m *MessageServiceMock) MinimockSaveMessageInspect() {
	for _, e := range m.SaveMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageServiceMock.SaveMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		if m.SaveMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageServiceMock.SaveMessage")
		} else {
			m.t.Errorf("Expected call to MessageServiceMock.SaveMessage with params: %#v", *m.SaveMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveMessage != nil && mm_atomic.LoadUint64(&m.afterSaveMessageCounter) < 1 {
		m.t.Error("Expected call to MessageServiceMock.SaveMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetMessagesByChatIdInspect()

			m.MinimockSaveMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessageServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetMessagesByChatIdDone() &&
		m.MinimockSaveMessageDone()
}
