// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/PerfilievAlexandr/chat-server/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/PerfilievAlexandr/chat-server/internal/api/grpc/chat/dto"
	proto "github.com/PerfilievAlexandr/chat-server/pkg/chat_v1"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ChatServiceMock implements service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConnectChat          func(req dto.ConnectChatRequest, stream proto.ChatV1_ConnectChatServer) (err error)
	inspectFuncConnectChat   func(req dto.ConnectChatRequest, stream proto.ChatV1_ConnectChatServer)
	afterConnectChatCounter  uint64
	beforeConnectChatCounter uint64
	ConnectChatMock          mChatServiceMockConnectChat

	funcCreateChat          func(ctx context.Context, req dto.CreateChatRequest) (u1 uuid.UUID, err error)
	inspectFuncCreateChat   func(ctx context.Context, req dto.CreateChatRequest)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatServiceMockCreateChat

	funcSendMessage          func(ctx context.Context, req dto.SendMessageRequest) (err error)
	inspectFuncSendMessage   func(ctx context.Context, req dto.SendMessageRequest)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectChatMock = mChatServiceMockConnectChat{mock: m}
	m.ConnectChatMock.callArgs = []*ChatServiceMockConnectChatParams{}

	m.CreateChatMock = mChatServiceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatServiceMockCreateChatParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockConnectChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockConnectChatExpectation
	expectations       []*ChatServiceMockConnectChatExpectation

	callArgs []*ChatServiceMockConnectChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockConnectChatExpectation specifies expectation struct of the ChatService.ConnectChat
type ChatServiceMockConnectChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockConnectChatParams
	results *ChatServiceMockConnectChatResults
	Counter uint64
}

// ChatServiceMockConnectChatParams contains parameters of the ChatService.ConnectChat
type ChatServiceMockConnectChatParams struct {
	req    dto.ConnectChatRequest
	stream proto.ChatV1_ConnectChatServer
}

// ChatServiceMockConnectChatResults contains results of the ChatService.ConnectChat
type ChatServiceMockConnectChatResults struct {
	err error
}

// Expect sets up expected params for ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Expect(req dto.ConnectChatRequest, stream proto.ChatV1_ConnectChatServer) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{}
	}

	mmConnectChat.defaultExpectation.params = &ChatServiceMockConnectChatParams{req, stream}
	for _, e := range mmConnectChat.expectations {
		if minimock.Equal(e.params, mmConnectChat.defaultExpectation.params) {
			mmConnectChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnectChat.defaultExpectation.params)
		}
	}

	return mmConnectChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Inspect(f func(req dto.ConnectChatRequest, stream proto.ChatV1_ConnectChatServer)) *mChatServiceMockConnectChat {
	if mmConnectChat.mock.inspectFuncConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.ConnectChat")
	}

	mmConnectChat.mock.inspectFuncConnectChat = f

	return mmConnectChat
}

// Return sets up results that will be returned by ChatService.ConnectChat
func (mmConnectChat *mChatServiceMockConnectChat) Return(err error) *ChatServiceMock {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	if mmConnectChat.defaultExpectation == nil {
		mmConnectChat.defaultExpectation = &ChatServiceMockConnectChatExpectation{mock: mmConnectChat.mock}
	}
	mmConnectChat.defaultExpectation.results = &ChatServiceMockConnectChatResults{err}
	return mmConnectChat.mock
}

// Set uses given function f to mock the ChatService.ConnectChat method
func (mmConnectChat *mChatServiceMockConnectChat) Set(f func(req dto.ConnectChatRequest, stream proto.ChatV1_ConnectChatServer) (err error)) *ChatServiceMock {
	if mmConnectChat.defaultExpectation != nil {
		mmConnectChat.mock.t.Fatalf("Default expectation is already set for the ChatService.ConnectChat method")
	}

	if len(mmConnectChat.expectations) > 0 {
		mmConnectChat.mock.t.Fatalf("Some expectations are already set for the ChatService.ConnectChat method")
	}

	mmConnectChat.mock.funcConnectChat = f
	return mmConnectChat.mock
}

// When sets expectation for the ChatService.ConnectChat which will trigger the result defined by the following
// Then helper
func (mmConnectChat *mChatServiceMockConnectChat) When(req dto.ConnectChatRequest, stream proto.ChatV1_ConnectChatServer) *ChatServiceMockConnectChatExpectation {
	if mmConnectChat.mock.funcConnectChat != nil {
		mmConnectChat.mock.t.Fatalf("ChatServiceMock.ConnectChat mock is already set by Set")
	}

	expectation := &ChatServiceMockConnectChatExpectation{
		mock:   mmConnectChat.mock,
		params: &ChatServiceMockConnectChatParams{req, stream},
	}
	mmConnectChat.expectations = append(mmConnectChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.ConnectChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockConnectChatExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockConnectChatResults{err}
	return e.mock
}

// ConnectChat implements service.ChatService
func (mmConnectChat *ChatServiceMock) ConnectChat(req dto.ConnectChatRequest, stream proto.ChatV1_ConnectChatServer) (err error) {
	mm_atomic.AddUint64(&mmConnectChat.beforeConnectChatCounter, 1)
	defer mm_atomic.AddUint64(&mmConnectChat.afterConnectChatCounter, 1)

	if mmConnectChat.inspectFuncConnectChat != nil {
		mmConnectChat.inspectFuncConnectChat(req, stream)
	}

	mm_params := ChatServiceMockConnectChatParams{req, stream}

	// Record call args
	mmConnectChat.ConnectChatMock.mutex.Lock()
	mmConnectChat.ConnectChatMock.callArgs = append(mmConnectChat.ConnectChatMock.callArgs, &mm_params)
	mmConnectChat.ConnectChatMock.mutex.Unlock()

	for _, e := range mmConnectChat.ConnectChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConnectChat.ConnectChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnectChat.ConnectChatMock.defaultExpectation.Counter, 1)
		mm_want := mmConnectChat.ConnectChatMock.defaultExpectation.params
		mm_got := ChatServiceMockConnectChatParams{req, stream}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnectChat.t.Errorf("ChatServiceMock.ConnectChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnectChat.ConnectChatMock.defaultExpectation.results
		if mm_results == nil {
			mmConnectChat.t.Fatal("No results are set for the ChatServiceMock.ConnectChat")
		}
		return (*mm_results).err
	}
	if mmConnectChat.funcConnectChat != nil {
		return mmConnectChat.funcConnectChat(req, stream)
	}
	mmConnectChat.t.Fatalf("Unexpected call to ChatServiceMock.ConnectChat. %v %v", req, stream)
	return
}

// ConnectChatAfterCounter returns a count of finished ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.afterConnectChatCounter)
}

// ConnectChatBeforeCounter returns a count of ChatServiceMock.ConnectChat invocations
func (mmConnectChat *ChatServiceMock) ConnectChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnectChat.beforeConnectChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.ConnectChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnectChat *mChatServiceMockConnectChat) Calls() []*ChatServiceMockConnectChatParams {
	mmConnectChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockConnectChatParams, len(mmConnectChat.callArgs))
	copy(argCopy, mmConnectChat.callArgs)

	mmConnectChat.mutex.RUnlock()

	return argCopy
}

// MinimockConnectChatDone returns true if the count of the ConnectChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockConnectChatDone() bool {
	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnectChat != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnectChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockConnectChatInspect() {
	for _, e := range m.ConnectChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		if m.ConnectChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.ConnectChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.ConnectChat with params: %#v", *m.ConnectChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnectChat != nil && mm_atomic.LoadUint64(&m.afterConnectChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.ConnectChat")
	}
}

type mChatServiceMockCreateChat struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateChatExpectation
	expectations       []*ChatServiceMockCreateChatExpectation

	callArgs []*ChatServiceMockCreateChatParams
	mutex    sync.RWMutex
}

// ChatServiceMockCreateChatExpectation specifies expectation struct of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockCreateChatParams
	results *ChatServiceMockCreateChatResults
	Counter uint64
}

// ChatServiceMockCreateChatParams contains parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParams struct {
	ctx context.Context
	req dto.CreateChatRequest
}

// ChatServiceMockCreateChatResults contains results of the ChatService.CreateChat
type ChatServiceMockCreateChatResults struct {
	u1  uuid.UUID
	err error
}

// Expect sets up expected params for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Expect(ctx context.Context, req dto.CreateChatRequest) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{}
	}

	mmCreateChat.defaultExpectation.params = &ChatServiceMockCreateChatParams{ctx, req}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Inspect(f func(ctx context.Context, req dto.CreateChatRequest)) *mChatServiceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Return(u1 uuid.UUID, err error) *ChatServiceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatServiceMockCreateChatResults{u1, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatService.CreateChat method
func (mmCreateChat *mChatServiceMockCreateChat) Set(f func(ctx context.Context, req dto.CreateChatRequest) (u1 uuid.UUID, err error)) *ChatServiceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatService.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatService.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceMockCreateChat) When(ctx context.Context, req dto.CreateChatRequest) *ChatServiceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatServiceMockCreateChatParams{ctx, req},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateChatExpectation) Then(u1 uuid.UUID, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateChatResults{u1, err}
	return e.mock
}

// CreateChat implements service.ChatService
func (mmCreateChat *ChatServiceMock) CreateChat(ctx context.Context, req dto.CreateChatRequest) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, req)
	}

	mm_params := ChatServiceMockCreateChatParams{ctx, req}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_got := ChatServiceMockCreateChatParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatServiceMock.CreateChat")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, req)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatServiceMock.CreateChat. %v %v", ctx, req)
	return
}

// CreateChatAfterCounter returns a count of finished ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceMockCreateChat) Calls() []*ChatServiceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateChatDone() bool {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && mm_atomic.LoadUint64(&m.afterCreateChatCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.CreateChat")
	}
}

type mChatServiceMockSendMessage struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockSendMessageParams
	results *ChatServiceMockSendMessageResults
	Counter uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx context.Context
	req dto.SendMessageRequest
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, req dto.SendMessageRequest) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, req}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, req dto.SendMessageRequest)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, req dto.SendMessageRequest) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, req dto.SendMessageRequest) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServiceMockSendMessageParams{ctx, req},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, req dto.SendMessageRequest) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, req)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, req}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServiceMockSendMessageParams{ctx, req}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, req)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v", ctx, req)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConnectChatInspect()

			m.MinimockCreateChatInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectChatDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockSendMessageDone()
}
